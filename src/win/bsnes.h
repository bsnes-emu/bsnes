class bJoypad {
public:
bool up, down, left, right;
bool a, b, x, y;
bool l, r, select, start;
  bJoypad();
};

class bSNES : public SNES {
private:
//If true, indicates a ROM is loaded and debugger output
//is possible.
bool is_debugger_activated;

//When true, notify() ignores read/write requests, as they
//have been generated by the debugging interface and not by
//the emulator.
bool debug_command;
uint32 run_status;

bool update_frame;

bJoypad joypad1, joypad2;

public:
enum {
  STOP = 0,
  RUN,
  RUNONCE,
  RUNTOSIGNAL,
  RUNTOFRAME,
  RUNTOCPUSTEP,
  RUNTOCPUPROCEED,
  RUNTOCPUTRACE,
  RUNTOAPUSTEP
};
enum { DRAM = 0, SPCRAM = 1, VRAM = 2, OAM = 3, CGRAM = 4 };
  void   set_status(uint32 new_status);
  uint32 get_status();
  void   snes_run();
  void   render_frame();

//input functions
  void poll_input();
  bool get_input_status(uint8 device, uint8 button);

//debugging functions
struct {
  uint32 cpu_stop_pos;
  uint32 cpu_trace_pos, cpu_trace_stop;
  bool   cpu_ran, apu_ran;
}status;
  uint8 read (uint8 type, uint32 addr);
  void  write(uint8 type, uint32 addr, uint8 value);
  void  notify(uint32 message, uint32 param1 = 0, uint32 param2 = 0);
  void  disassemble_cpu_op();
  void  disassemble_apu_op();
  void  disassemble_bp_op();

//whether or not the user requests the debugger open
  bool  debugger_enabled();
  void  debugger_enable();
  void  debugger_disable();
  void  debugger_update();

//whether or not the debugger *can* be used
//e.g., debugger cannot be used without ROM loaded
  bool  debugger_activated();
  void  debugger_activate();
  void  debugger_deactivate();

  bSNES();
};

bSNES *bsnes;
